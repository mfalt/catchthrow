%Vad blir en bra ordning på rubrikerna? Är rubrikerna bra? lekte lite med ordningen på rubrikerna så att klasserna som beskrivs i varje rubrik har nämnts i texten/rubriken innan, vet inte om det är bra
%hur ska vi göra med klasser vi inte skrivit?

From a realtime point of view the code structure consists of two threads involved in the control, called RegulThread and SwitchThread, and one monitor class for the synchronization of their work. RegulThread has the task of calculating a control signal each sample by calling the calculateOutput method in the monitor which in turn calls the method of the currently active controller, and SwitchThread has the task of switching between controllers and reference generators, see figure \ref{overall_fig}. The monitor handles the synchronization needed when a switch is made but also some scheduling in the sense that it puts the SwitchThread to sleep and wakes it up when it is needed again. The monitor is one of the central parts of the code and offers synchronization for other tasks too which will be described bellow in the context of each class using it. 
\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{figures/Overall.png}
\caption{Abstracted UML of the code structure only showing the two threads involved in control and the  monitor. The name of the methods are not the same as in the actual code. The helper classes they use in doing their
task are for readability reasons not shown but are described in detail in the subsections of this chapter.}
\label{overall_fig}
\end{figure}

\subsubsection{Main.java}
%behöver nog inte beskrivas så ingående

\subsection{Threads}

\subsubsection{RegulThread.java}

\subsubsection{SwitchThread.java}

\subsection{Checker classes}
Checker classes provide a method to determine if a state is "OK" in some way. We use this to find out when we should continue to the next part of the catch-throw sequence. These classes are found in the \texttt{checker} package.
\subsubsection{StateChecker.java}
\texttt{StateChecker} is the abstract superclass of all the checkers. It has two methods.

The method \texttt{check(double[])} receives our measured values and returns a boolean describing if the state of the system fulfills some condition, depending on the implementation in subclasses.

\texttt{reset()} is used when activating a checker to reset their internal states, so any previous usage of the object won't  affect the current workings. This method will be empty in subclasses that have no internal state.

%\subsubsection{BallOnBeamChecker.java}
%just nu använder vi inte den här, men det finns förändringar vi kan göra för att den ska funka

\subsubsection{ConstBallChecker.java}
This subclass checks if a ball has been around a specified point on the beam for a sufficient number of samples in a row. It provides the method \texttt{setValue(double)} for choosing the wanted stationary point.

\subsubsection{ConstBeamChecker.java}
Exactly the same as \texttt{ConstBallChecker}, except for the angle of the beam.

\subsubsection{LEDChecker.java}
Checks if the beam is in the pickup position - in other words if the LED is on. This is done by actually reading the digital in channel.

\subsubsection{Null checker}
Though not a class, the monitor has the ability to set the "null checker", which is roughly equivalent to turning off checking. This is not needed, since calling a checker when SwitchThread is not waiting or ready to run does nothing except waste time, but it can avoid unneccesary processor load to some extent.

\subsection{Regulator classes}
Regulator classes determine how the control signal should be calculated, given measured states and reference values. They are found in the \texttt{regul} package.

\subsubsection{Regul.java}
This is the abstract superclass of all regulators. It has the abstract methods \texttt{calculateOutput}, \texttt{updateState} and \texttt{reset}.

\texttt{double calculateOutput(double[] measurement, double[] ref, double h)} takes the measured values, the reference values, and the period $h$ and calculates a desired control signal depending on the implementation in subclasses.

\texttt{void updateState(double h)} updates all the values that need updating before the next sample, but aren't needed to calculate the control signal for the current sample. This method is called after sending the control signal to the process, to minimize the delay between input and output.

The method \texttt{void reset(double[] states)} is used to reset the regulator after it has been activated, so it has relevant internal values that fit the current state of the system.

\subsubsection{BeamRegul.java}
\texttt{BeamRegul} is a PID regulator for controlling the angle of the beam. In addition to the implementations of the abstract methods, it also has a getter and a setter for the parameters (described by a \texttt{PIDParameters} object).

\subsubsection{BeamBallRegul.java}
This subclass is a cascaded PID regulator for controlling the position of the ball. It is like \texttt{BeamRegul}, except it also has a reference to a \texttt{BeamRegul} object inside itself. In this way, we get a simple way of describing a cascaded PID regulator. When calculating the control signal, this class calls the \texttt{calculateOutput} of its inner regulator. The same goes for updating and resetting.

%Vet inte vilka andra regulatorer som faktiskt används... Tror det bara är de där två ^


\subsection{Reference generator classes}
Reference generators are classes that determine where the reference values for the process should be at a particular point in time. Whenever the regulator thread needs a reference value, it requests it from the currently chosen reference generator  (through a call to a monitor method). These classes are found in the \texttt{refgen} package.
 
\subsubsection{ReferenceGenerator.java}
This is the abstract superclass of the reference generators, and has the methods \texttt{double[] getRef()}, \texttt{void resetTime()} and \texttt{double getTimeSeconds()}.

\texttt{getRef()} must be implemented in subclasses, and is meant to return the current reference value.


\texttt{resetTime()} sets the starting time of the reference generator to the current time, essentially "resetting" it. Called whenever a reference generator is selected, but not relevant for time invariant subclasses.
%Inte säker på om denna metod används längre (av någon anledning), så isåfall bör den tas bort.
\texttt{getTimeSeconds()} gives the time in seconds since \texttt{resetTime()} was last called. Again not relevant for time invariant generators.

\subsubsection{ConstantRef.java}
This subclass gives a constant reference value chosen by calling \texttt{setRef(double)}. Which state the reference in an instance of this class refers to is given by the private variable \texttt{actualState} which is sent to the constructor at the creation of the object.

\subsubsection{ConstantVectorRef.java}
%Används denna?
This class works the same as \texttt{ConstantRef}, but gives references to all states of the system.

\subsubsection{ConstPosRampAngleRef.java}
%används denna?

\subsubsection{RampRef.java}
\texttt{RampRef} gives a reference that changes linearly over time, and includes methods to set the slope and initial reference. Like in \texttt{ConstantRef}, a variable is used to determine which state the reference value in the current instance of the class refers to.

\subsubsection{RampToRef.java}
This subclass works almost like \texttt{RampRef}, except it stops when a chosen reference value has been reached. This gives a smoother reference change.

\subsubsection{RefGenGUI.java}
This is a slightly modified version of the \texttt{ReferenceGenerator} found in Lab 1, and was used for testing.

\subsubsection{TrajectoryRef}
%används denna?
This subclass gives a reference that follows a curve loaded from a matlab file.

\subsection{Miscellaneous classes} 	%Beskrivning av klasser som inte passar in under andra rubriker, tex Main och OpCom
%tror även Monitor bör få en snabb beskrivning här, men de flesta metoder i monitorn bör förklaras i beskrivningen av de klasser som faktiskt använder dem.




