
public class BeamBallRegul extends Regul {

	private PIDParameters p;
	private double P, I, D;
	private double ad, bd, bi, ar;
	private double v, y, yref, yold;
	
	/** Constructor */
	public BeamBallRegul(){
		p = new PIDParameters();
		p.K = -0.1;
		p.Ti = 0.0;
		p.Tr = 0.0;
		p.Td = 1.0;
		p.N = 6.0;
		p.Beta = 1.0;
		p.H = 0.1;
		p.integratorOn = false;
		setParameters(p);
		I = 0;
		D = 0;
		yold = 0;
	}
	
	/** calculates the control signal
	 *  as for now it returns a double, to be changed
	 *  to an OutSignal object if needed when we do
	 *  more advanced stuffs
	 */
	public double calculateOutput(double[] y, double yref) {
		this.y = y[1];
		this.yref = yref;
		ad = p.Td/(p.Td + p.N*p.H);
		bd = p.K*p.N*ad;
		P = p.K*(p.Beta*yref - y);
		D = ad*D - bd*(y - yold);
		v = P + I + D;
		return v;
	}

	/** updates the controller state
	 *  uses tracking-based anti-windup
	 */
	public void updateState(double u) {
		if(p.integratorOn) {
			bi = p.K*p.H/p.Ti;
			ar = p.H/p.Tr;
			I = I + bi*(yref - y) + ar*(u - v); 
			} else {
				I = 0.0;
			}
		yold = y;
	}
	
	public void setParameters(PIDParameters newParameters) {
		p = (PIDParameters)newParameters.clone();
		if (!p.integratorOn) {
			I = 0.0;
		}
	}
	
	public PIDParameters getParameters() {
		return p;
	}
	
	
	/** returns this controller's sampling interval*/
	public long getHMillis() {
		return (long) (p.H*1000.0);
	}
		
	
}


