import se.lth.control.DoublePoint;
import se.lth.control.realtime.AnalogIn;
import se.lth.control.realtime.AnalogOut;
import se.lth.control.realtime.IOChannelException;
import se.lth.control.realtime.Semaphore;


public class RegulThread extends Thread {
	
	private Monitor mon;
	private Opcom opcom;
	private boolean shouldRun = true;
	private Semaphore mutex; // used for synchronization at shut-down
	
	//input and output analog signals to and from the real process
	private AnalogIn analogInAngle;        // angle of the beam = yAngle
	private AnalogIn analogInPosition;     // position of the ball = yPos
	private AnalogOut analogOut;           // angle of the beam = uAngle
	
	private double yPos, yAngle, uAngle, ref;
	private ReferenceGenerator referenceGenerator;
	
	/** Constructor */
	public RegulThread(Monitor monitor, int prio) {
		
		//set up the analog signals
		try {
			analogInAngle = new AnalogIn(0);
			analogInPosition = new AnalogIn(1);
			analogOut = new AnalogOut(0);
		} catch (IOChannelException e) { 
			System.out.print("Error: IOChannelException: ");
			System.out.println(e.getMessage());
		}
		
		mon = monitor;
		mutex = new Semaphore(1);
		setPriority(prio);
	}
	
	public void setRefGen(ReferenceGenerator referenceGenerator){
		this.referenceGenerator = referenceGenerator;
	}
	
	public void setOpcom(Opcom opcom) {
		this.opcom = opcom;
	}
	
	private double limit(double v, double min, double max) {
		if (v < min) {
			v = min;
		} else if (v > max) {
			v = max;
		}
		return v;
	}
	
	/** Called from OpCom when shutting down */
	public synchronized void shutDown() {
		shouldRun = false;
		mutex.take();
		try {
			analogOut.set(0.0);
		} catch (IOChannelException x) {
		}
	}
	
	
	public void run() {
		long startTime = System.currentTimeMillis();
		
		mutex.take();
		while(shouldRun) {
			
			//get the angle of the beam and its set point
			try {
				yAngle = analogInAngle.get();
			} catch (IOChannelException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			ref = referenceGenerator.getRef();
			
			synchronized(mon){ //to get synchronization between calcOutput and updateState
				uAngle = mon.calcOutput(yAngle, ref);
				uAngle = limit(uAngle, -10, 10); //anti-windup
			
				//send the control signal to the real process
				try {
					analogOut.set(uAngle);
				} catch (IOChannelException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			
			
				double x = (double)(System.currentTimeMillis() - startTime) / 1000.0;
				DoublePoint dp = new DoublePoint(x,uAngle);
				PlotData pd = new PlotData(x,ref,yAngle);
				opcom.putControlDataPoint(dp);
				opcom.putMeasurementDataPoint(pd);
				mon.updateState(uAngle);
			}
			
		}
		mutex.give();
		
	}

}
